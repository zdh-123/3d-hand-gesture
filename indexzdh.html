<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D ç²’å­ - æ‘„åƒå¤´ä¿®å¤ç‰ˆ</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: -apple-system, sans-serif;
            touch-action: none;
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ‘„åƒå¤´å°çª— */
        #video-input { 
            position: absolute; bottom: 15px; left: 15px; 
            width: 100px; height: auto; opacity: 1; 
            z-index: 10; border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: scaleX(-1); 
            pointer-events: none;
        }
        
        /* åŠ è½½ä¸è°ƒè¯•å±‚ */
        #loading-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 20; padding: 20px; box-sizing: border-box;
        }
        .spinner { width: 30px; height: 30px; border: 3px solid #333; border-top: 3px solid #ff0000; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* é”™è¯¯æ—¥å¿—æ˜¾ç¤ºåŒº (çº¢è‰²æ–‡å­—) */
        #error-log {
            color: #ff3333; font-size: 14px; line-height: 1.5; 
            text-align: left; max-width: 90%; 
            background: rgba(20,0,0,0.8); padding: 10px; border-radius: 8px;
            margin-top: 20px; white-space: pre-wrap; display: none;
        }

        #status-text { color: #fff; font-size: 16px; }

        /* æŒ‰é’®ç»„ */
        .ui-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 5; 
            display: flex; gap: 10px; align-items: center;
        }
        .btn {
            padding: 8px 16px; border-radius: 20px; cursor: pointer; 
            font-size: 13px; backdrop-filter: blur(5px); 
            transition: all 0.3s; border: none; outline: none; font-weight: bold;
        }
        #action-btn {
            background: rgba(255, 20, 147, 0.85); color: white;
            box-shadow: 0 0 10px rgba(255, 20, 147, 0.4);
            animation: pulse-btn 2s infinite ease-in-out; min-width: 70px; 
        }
        @keyframes pulse-btn { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        #fullscreen-btn { background: rgba(255, 255, 255, 0.15); color: rgba(255, 255, 255, 0.8); }

        #gesture-hint {
            position: absolute; top: 20px; width: 100%; color: rgba(255,255,255,0.4); 
            font-size: 12px; pointer-events: none; z-index: 2; 
            text-align: center; transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading-layer">
        <div class="spinner"></div>
        <div id="status-text">ç³»ç»Ÿè‡ªæ£€ä¸­...</div>
        <div id="error-log"></div>
    </div>
    
    <div id="gesture-hint">ğŸ–ï¸ å¯¹ç€å·¦ä¸‹è§’é•œå¤´å¼ æ‰‹å¼€å§‹</div>
    <video id="video-input" playsinline webkit-playsinline muted autoplay></video>
    <div id="canvas-container"></div>
    
    <div class="ui-container">
        <button id="action-btn" class="btn">ç‚¹è¿™é‡Œ</button>
        <button id="fullscreen-btn" class="btn">å…¨å±</button>
    </div>

<script>
    // === æ•…éšœè¯Šæ–­å·¥å…· ===
    function logError(msg) {
        console.error(msg);
        const logDiv = document.getElementById('error-log');
        const statusDiv = document.getElementById('status-text');
        document.querySelector('.spinner').style.display = 'none'; // åœæ­¢è½¬åœˆ
        statusDiv.innerText = "âš ï¸ å‘ç”Ÿé”™è¯¯";
        statusDiv.style.color = "#ff3333";
        logDiv.style.display = 'block';
        logDiv.innerText += "âŒ " + msg + "\n";
    }
    
    function logInfo(msg) {
        console.log(msg);
        document.getElementById('status-text').innerText = msg;
    }

    // 1. æ£€æŸ¥ HTTPS
    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        logError("å®‰å…¨ç¯å¢ƒé”™è¯¯ï¼š\nå½“å‰ä¸æ˜¯ HTTPS åè®®ã€‚\nè‹¹æœæ‰‹æœºç¦æ­¢é HTTPS ç½‘é¡µè°ƒç”¨æ‘„åƒå¤´ã€‚\nè¯·éƒ¨ç½²åˆ° GitHub Pages æˆ–ä½¿ç”¨ Ngrokã€‚");
        throw new Error("HTTPS Required");
    }

    // === é…ç½® ===
    const config = {
        particleCount: 15000, 
        particleSize: 0.18,
        color: '#ff0000', 
        shape: 'flower', 
        interactionStrength: 0,
        handDetected: false
    };

    const shapeList = ['flower', 'heart', 'star', 'buddha', 'fireworks'];
    let currentShapeIndex = 0;
    let wasHandClosed = false; 

    let targetRotationX = 0, targetRotationY = 0;
    let scene, camera, renderer, containerGroup; 
    let particles, geometry; 
    let targetPositions = [], initialPositions = [], particleVelocities = []; 
    let textParticles, textGeometry; 
    let textTargetPositions = [], textInitialPositions = [];
    let textParticleCount = 0;
    let smoothInteraction = 0; 
    
    const STATE_NORMAL = 0, STATE_HEARTBEAT = 1, STATE_FW_STAGE1_EXPLODE_CURRENT = 2, STATE_FW_STAGE2_ROCKET_UP = 3, STATE_FW_STAGE3_BLOOM = 4, STATE_FW_STAGE4_FADE_OUT = 5;        
    let appState = STATE_NORMAL;
    let globalOpacity = 1.0; 
    const explosionCenterY = 25; 
    const rocketParticleCount = 100; 

    // === åˆå§‹åŒ–é€»è¾‘ ===
    function initThree() {
        logInfo("æ­£åœ¨å¯åŠ¨ 3D å¼•æ“...");
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        containerGroup = new THREE.Group();
        scene.add(containerGroup);

        createParticles(); 
        generateShape(config.shape);
        createTextParticles('å±±é£', 0, false); 
        
        window.addEventListener('resize', onWindowResize, false);
        animate();
        
        // 3D å¯åŠ¨æˆåŠŸåï¼Œå°è¯•å¯åŠ¨ AI
        startAI();
    }

    // === AI ä¸æ‘„åƒå¤´å¯åŠ¨ (å¸¦é‡è¯•æœºåˆ¶) ===
    async function startAI() {
        logInfo("åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹ (å›½å†…æº)...");
        const videoElement = document.getElementById('video-input');

        try {
            const hands = new Hands({locateFile: (file) => {
                return `https://npm.elemecdn.com/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            logInfo("è¯·æ±‚æ‘„åƒå¤´æƒé™...");
            
            // å°è¯•ç›´æ¥è·å–æµï¼Œçœ‹çœ‹æ˜¯å¦æŠ¥é”™
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: 320, height: 240 } 
                });
                videoElement.srcObject = stream;
                await videoElement.play();
            } catch (cameraErr) {
                logError("æ— æ³•æ‰“å¼€æ‘„åƒå¤´ï¼š\n" + cameraErr.name + "\nè¯·æ£€æŸ¥æ‰‹æœºè®¾ç½®-Safari-æ‘„åƒå¤´æƒé™ï¼Œå¹¶ç¡®ä¿é€‰æ‹©äº†â€œå…è®¸â€ã€‚");
                return;
            }

            logInfo("AI å¼•æ“å¯åŠ¨ä¸­...");
            
            // ä½¿ç”¨ cameraUtils æŒç»­å‘é€å¸§
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            await camera.start();
            
            // æˆåŠŸï¼éšè—åŠ è½½å±‚
            document.getElementById('loading-layer').style.display = 'none';

        } catch (err) {
            logError("AIæ¨¡å‹åŠ è½½å¤±è´¥ï¼š\n" + err.message + "\nå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜ï¼Œè¯·å°è¯•åˆ‡æ¢WiFi/4Gã€‚");
        }
    }

    // === æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ (ä¿æŒä¸å˜) ===
    function onHandsResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const videoElem = document.getElementById('video-input');
            if (videoElem.style.opacity !== '0') {
                videoElem.style.opacity = '0'; // éšè—æ‘„åƒå¤´
                document.getElementById('gesture-hint').style.opacity = '0'; // éšè—æç¤º
            }
        }

        if (appState >= STATE_FW_STAGE1_EXPLODE_CURRENT) { config.handDetected = false; return; }
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            config.handDetected = true; 
            const landmarks = results.multiHandLandmarks[0]; 
            const thumbTip = landmarks[4]; const indexTip = landmarks[8]; 
            const distance = Math.sqrt(Math.pow(thumbTip.x-indexTip.x, 2) + Math.pow(thumbTip.y-indexTip.y, 2));
            
            let factor = (distance - 0.03) / (0.15 - 0.03); 
            config.interactionStrength = Math.max(0, Math.min(1, factor));

            const palmCenter = landmarks[9];
            targetRotationY = (palmCenter.x - 0.5) * 4; 
            targetRotationX = (palmCenter.y - 0.5) * 2; 
        } else {
            config.handDetected = false; 
            if(appState === STATE_NORMAL) config.interactionStrength = 0.8 + 0.2 * Math.sin(Date.now() * 0.001); 
        }
    }

    // ... [ä»¥ä¸‹ä¸ºç”Ÿæˆç²’å­ã€åŠ¨ç”»å¾ªç¯ç­‰æ ‡å‡†é€»è¾‘ï¼Œä¿æŒåŸæ ·] ...
    function generateTextData(text, offsetY = 0, isFlat = false) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = 512; const height = 256; 
        canvas.width = width; canvas.height = height;
        let fontSize = 32; if (text.length > 5) fontSize = 20; 
        ctx.font = `bold ${fontSize}px Arial, "Helvetica Neue", sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(text, width / 2, height / 2);
        const imgData = ctx.getImageData(0, 0, width, height).data;
        const points = []; const step = 2; const scale = 0.07; const thickness = 2.5; const layers = isFlat ? 1 : 8; 
        for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
                if (imgData[(y * width + x) * 4 + 3] > 128) {
                    const pX = (x - width / 2) * scale; const pY = (height / 2 - y) * scale + offsetY; 
                    for (let l = 0; l < layers; l++) { 
                        let pZ = 0;
                        if(!isFlat) pZ = ((l / (layers - 1)) - 0.5) * thickness;
                        points.push(pX, pY, pZ); 
                    }
                }
            }
        }
        return points;
    }

    function createTextParticles(text, offsetY, isFlat) {
        if (textParticles) { containerGroup.remove(textParticles); if(textGeometry) textGeometry.dispose(); }
        if (!text) { textParticles = null; return; }
        const textPointsData = generateTextData(text, offsetY, isFlat);
        textParticleCount = textPointsData.length / 3;
        textGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(textParticleCount * 3);
        const colors = new Float32Array(textParticleCount * 3);
        const colorObj = new THREE.Color(config.color);
        for (let i = 0; i < textParticleCount; i++) {
            textTargetPositions[i*3] = textPointsData[i*3];
            textTargetPositions[i*3+1] = textPointsData[i*3+1];
            textTargetPositions[i*3+2] = textPointsData[i*3+2];
            const ix = (Math.random() - 0.5) * 60; const iy = (Math.random() - 0.5) * 60; const iz = (Math.random() - 0.5) * 60;
            textInitialPositions.push(ix, iy, iz);
            positions[i*3] = ix; positions[i*3+1] = iy; positions[i*3+2] = iz;
            colors[i*3] = colorObj.r; colors[i*3+1] = colorObj.g; colors[i*3+2] = colorObj.b;
        }
        textGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        textGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({ size: config.particleSize * 0.7, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0 });
        textParticles = new THREE.Points(textGeometry, material);
        containerGroup.add(textParticles);
    }

    function createParticles() {
        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.particleCount * 3);
        const colors = new Float32Array(config.particleCount * 3);
        const colorObj = new THREE.Color(config.color);
        particleVelocities = new Float32Array(config.particleCount * 3);
        for (let i = 0; i < config.particleCount; i++) {
            const x = (Math.random() - 0.5) * 100; const y = (Math.random() - 0.5) * 100; const z = (Math.random() - 0.5) * 100;
            positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
            initialPositions.push(x, y, z); targetPositions.push(0, 0, 0);
            colors[i * 3] = colorObj.r; colors[i * 3 + 1] = colorObj.g; colors[i * 3 + 2] = colorObj.b;
            particleVelocities[i*3] = 0; particleVelocities[i*3+1] = 0; particleVelocities[i*3+2] = 0;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({ size: config.particleSize, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.8 });
        particles = new THREE.Points(geometry, material);
        containerGroup.add(particles);
    }

    function generateShape(type) {
        let idx = 0;
        for (let i = 0; i < config.particleCount; i++) {
            let x, y, z;
            if (type === 'heart') {
                const t = Math.random() * Math.PI * 2; const fillScale = Math.cbrt(Math.random());
                x = (17 * Math.pow(Math.sin(t), 3)) * fillScale;
                y = (15 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * fillScale;
                const currentThickness = 8 * Math.sqrt(1 - fillScale*fillScale);
                z = (Math.random() - 0.5) * 2 * currentThickness;
                x *= 0.75; y *= 0.75; z *= 0.75;
            } 
            else if (type === 'flower') { const u = Math.random()*Math.PI*2, v = Math.random()*Math.PI, r = 10*(1+0.5*Math.sin(5*u)*Math.sin(v)); x = r*Math.sin(v)*Math.cos(u); y = r*Math.sin(v)*Math.sin(u); z = r*Math.cos(v); } 
            else if (type === 'star') { const r = 12, theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1); x = r*Math.sin(phi)*Math.cos(theta); y = r*Math.sin(phi)*Math.sin(theta); z = r*Math.cos(phi); if (i%5===0) { const ringR=18+Math.random()*4, ringT=Math.random()*Math.PI*2; x=ringR*Math.cos(ringT); y=0.5*(Math.random()-0.5); z=ringR*Math.sin(ringT); }} 
            else if (type === 'buddha') { if (i<config.particleCount*0.15) { const r=3, u=Math.random()*Math.PI*2, v=Math.random()*Math.PI; x=r*Math.sin(v)*Math.cos(u); y=r*Math.sin(v)*Math.sin(u)+8; z=r*Math.cos(v); } else { const r=8*Math.random(), h=12*Math.random()-6, theta=Math.random()*Math.PI*2, width=(1-(h+6)/14)*10; x=width*Math.cos(theta)*Math.sqrt(Math.random()); y=h; z=width*Math.sin(theta)*Math.sqrt(Math.random()); }} 
            else if (type === 'fireworks') { const r=25*Math.random(), theta=Math.random()*Math.PI*2, phi=Math.random()*Math.PI; x=r*Math.sin(phi)*Math.cos(theta); y=r*Math.sin(phi)*Math.sin(theta); z=r*Math.cos(phi); }
            targetPositions[idx] = x; targetPositions[idx+1] = y; targetPositions[idx+2] = z; idx += 3;
        }
    }

    function handleUiAction() {
        const btn = document.getElementById('action-btn');
        if (appState === STATE_NORMAL) {
            appState = STATE_HEARTBEAT;
            btn.innerHTML = "æ”¾çƒŸèŠ±"; 
            btn.style.background = "#ff3333"; 
            createTextParticles("", 0, false); 
            config.shape = 'heart'; generateShape('heart');
            document.body.style.backgroundColor = "#1a0000";
        } else if (appState === STATE_HEARTBEAT) {
            startFireworksSequence();
        }
    }

    function startFireworksSequence() {
        const btn = document.getElementById('action-btn');
        btn.innerHTML = "ç‡ƒæ”¾ä¸­..."; btn.style.pointerEvents = "none"; btn.style.opacity = 0.6;
        appState = STATE_FW_STAGE1_EXPLODE_CURRENT;
        const positions = geometry.attributes.position.array;
        for(let i=0; i<config.particleCount; i++) {
            particleVelocities[i*3] = positions[i*3] * 0.08 * (Math.random() + 0.5);
            particleVelocities[i*3+1] = positions[i*3+1] * 0.08 * (Math.random() + 0.5);
            particleVelocities[i*3+2] = positions[i*3+2] * 0.08 * (Math.random() + 0.5);
        }
        if(textParticles) textParticles.material.opacity = 0;
        setTimeout(() => {
            appState = STATE_FW_STAGE2_ROCKET_UP;
            const positions = geometry.attributes.position.array;
            for(let i=0; i<config.particleCount; i++) {
                if (i < rocketParticleCount) {
                    positions[i*3] = (Math.random()-0.5) * 0.5; 
                    positions[i*3+1] = -50 + (Math.random()-0.5) * 0.5; 
                    positions[i*3+2] = (Math.random()-0.5) * 0.5;
                    particleVelocities[i*3] = 0; 
                    particleVelocities[i*3+1] = 1.4 + Math.random()*0.2; 
                    particleVelocities[i*3+2] = 0;
                } else {
                    positions[i*3+1] = -9999; 
                    particleVelocities[i*3] = 0; particleVelocities[i*3+1] = 0; particleVelocities[i*3+2] = 0;
                }
            }
            geometry.attributes.position.needsUpdate = true;
            particles.material.opacity = 1.0; 
        }, 1500);
    }

    function checkRocketHeight() {
        const positions = geometry.attributes.position.array;
        if (positions[1] > explosionCenterY) { triggerBigBloom(); }
    }

    function triggerBigBloom() {
        appState = STATE_FW_STAGE3_BLOOM;
        particles.material.opacity = 1.0;
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.color.array;
        for(let i=0; i<config.particleCount; i++) {
            positions[i*3] = 0; positions[i*3+1] = explosionCenterY; positions[i*3+2] = 0;
            const theta = Math.random() * Math.PI * 2; 
            const phi = Math.acos(2 * Math.random() - 1); 
            const speed = 0.5 + Math.random() * 0.8; 
            particleVelocities[i*3] = speed * Math.sin(phi) * Math.cos(theta);
            particleVelocities[i*3+1] = speed * Math.sin(phi) * Math.sin(theta);
            particleVelocities[i*3+2] = speed * Math.cos(phi);
            const color = new THREE.Color();
            color.setHSL(Math.random(), 1.0, 0.6 + Math.random()*0.2);
            colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true; 
        setTimeout(() => { appState = STATE_FW_STAGE4_FADE_OUT; }, 2500);
    }

    function restoreApp() {
        appState = STATE_NORMAL; globalOpacity = 1.0; particles.material.opacity = 0.8;
        const btn = document.getElementById('action-btn'); 
        btn.innerHTML = "ç‚¹è¿™é‡Œ"; btn.style.background = "rgba(255, 20, 147, 0.85)"; btn.style.pointerEvents = "auto"; btn.style.opacity = 1; 
        
        createTextParticles("å±±é£", 0, false); 
        config.shape = 'flower'; generateShape('flower'); 
        document.body.style.backgroundColor = "#000000"; containerGroup.scale.set(1,1,1);
        smoothInteraction = 0; config.interactionStrength = 0;
        for(let i=0; i<config.particleCount*3; i++) particleVelocities[i] = 0;
        const colorObj = new THREE.Color(config.color);
        const colors = geometry.attributes.color.array;
        for(let i=0; i<config.particleCount; i++) { colors[i*3] = colorObj.r; colors[i*3+1] = colorObj.g; colors[i*3+2] = colorObj.b; }
        geometry.attributes.color.needsUpdate = true;
        
        containerGroup.rotation.set(0,0,0);
        targetRotationX = 0; targetRotationY = 0;
    }

    function switchToNextShape() {
        currentShapeIndex = (currentShapeIndex + 1) % shapeList.length;
        const nextShape = shapeList[currentShapeIndex];
        config.shape = nextShape;
        generateShape(nextShape);
    }

    function animate() {
        requestAnimationFrame(animate);
        let currentStrength = 1; let heartScale = 1; const positions = geometry.attributes.position.array;

        // æ‰‹åŠ¨æ§åˆ¶æ—‹è½¬
        if (config.handDetected && appState <= STATE_HEARTBEAT) {
            containerGroup.rotation.y += (targetRotationY - containerGroup.rotation.y) * 0.1;
            containerGroup.rotation.x += (targetRotationX - containerGroup.rotation.x) * 0.1;
        } else if (appState === STATE_NORMAL) {
            containerGroup.rotation.y += 0.002;
            containerGroup.rotation.x += (0 - containerGroup.rotation.x) * 0.05;
        }

        switch (appState) {
            case STATE_FW_STAGE1_EXPLODE_CURRENT: 
                for(let i=0; i<config.particleCount; i++) {
                    positions[i*3] += particleVelocities[i*3]; positions[i*3+1] += particleVelocities[i*3+1]; positions[i*3+2] += particleVelocities[i*3+2];
                    particleVelocities[i*3+1] -= 0.02; 
                }
                geometry.attributes.position.needsUpdate = true;
                if(textParticles && textParticles.material.opacity > 0) textParticles.material.opacity -= 0.08;
                break;

            case STATE_FW_STAGE2_ROCKET_UP: 
                for(let i=0; i<rocketParticleCount; i++) {
                    positions[i*3+1] += particleVelocities[i*3+1];
                }
                geometry.attributes.position.needsUpdate = true;
                checkRocketHeight();
                break;

            case STATE_FW_STAGE3_BLOOM: 
            case STATE_FW_STAGE4_FADE_OUT:       
                for(let i=0; i<config.particleCount; i++) {
                    particleVelocities[i*3] *= 0.96; particleVelocities[i*3+1] *= 0.96; particleVelocities[i*3+2] *= 0.96;
                    particleVelocities[i*3+1] -= 0.008; 
                    positions[i*3] += particleVelocities[i*3]; positions[i*3+1] += particleVelocities[i*3+1]; positions[i*3+2] += particleVelocities[i*3+2];
                }
                geometry.attributes.position.needsUpdate = true;
                if (appState === STATE_FW_STAGE4_FADE_OUT) {
                    globalOpacity -= 0.01; particles.material.opacity = Math.max(0, globalOpacity);
                    if (globalOpacity <= 0) restoreApp(); 
                }
                break;

            default: 
                if (appState === STATE_HEARTBEAT) {
                    currentStrength = 1; const time = Date.now() * 0.006; const beat = Math.pow(Math.abs(Math.sin(time)), 3); heartScale = 1.0 + 0.15 * beat;
                } else {
                    const lerpSpeed = config.handDetected ? 0.12 : 0.05; smoothInteraction += (config.interactionStrength - smoothInteraction) * lerpSpeed; currentStrength = smoothInteraction; heartScale = 1;
                    
                    // ã€çµæ•åˆ‡å›¾ã€‘æ¡æ‹³ç¬é—´ (strength < 0.25) å³è§¦å‘åˆ‡æ¢
                    if (smoothInteraction < 0.25 && !wasHandClosed) {
                        wasHandClosed = true;
                        switchToNextShape(); 
                    } else if (smoothInteraction > 0.6) {
                        wasHandClosed = false; 
                    }
                }
                for (let i = 0; i < config.particleCount; i++) {
                    const px=i*3, py=i*3+1, pz=i*3+2; const tx=targetPositions[px], ty=targetPositions[py], tz=targetPositions[pz]; const ix=textInitialPositions[px], iy=textInitialPositions[py], iz=textInitialPositions[pz];
                    let cx = ix + (tx - ix) * currentStrength; let cy = iy + (ty - iy) * currentStrength; let cz = iz + (tz - iz) * currentStrength;
                    if (appState === STATE_HEARTBEAT) { cx *= heartScale; cy *= heartScale; cz *= heartScale; }
                    positions[px] += (cx - positions[px]) * 0.1; positions[py] += (cy - positions[py]) * 0.1; positions[pz] += (cz - positions[pz]) * 0.1;
                }
                geometry.attributes.position.needsUpdate = true;
                
                if (textParticles) {
                    const textPos = textGeometry.attributes.position.array;
                    for (let i = 0; i < textParticleCount; i++) {
                        const px=i*3, py=i*3+1, pz=i*3+2; const tx=textTargetPositions[px], ty=textTargetPositions[py], tz=textTargetPositions[pz]; const ix=textInitialPositions[px], iy=textInitialPositions[py], iz=textInitialPositions[pz];
                        let tx_final = ix + (tx - ix) * currentStrength; let ty_final = iy + (ty - iy) * currentStrength; let tz_final = iz + (tz - iz) * currentStrength;
                        textPos[px] += (tx_final - textPos[px]) * 0.1; textPos[py] += (ty_final - textPos[py]) * 0.1; textPos[pz] += (tz_final - textPos[pz]) * 0.1;
                    }
                    textGeometry.attributes.position.needsUpdate = true;
                    let textOpacity = (appState === STATE_HEARTBEAT) ? 1.0 : (currentStrength - 0.5) * 2; textParticles.material.opacity = Math.max(0, Math.min(1.0, textOpacity));
                }
                break;
        }

        containerGroup.scale.set(1, 1, 1); 
        
        const fsBtn = document.getElementById('fullscreen-btn');
        if (appState >= STATE_FW_STAGE1_EXPLODE_CURRENT || (appState === STATE_NORMAL && currentStrength > 0.9)) { fsBtn.style.opacity = '0'; fsBtn.style.pointerEvents = 'none'; } else { fsBtn.style.opacity = '1'; fsBtn.style.pointerEvents = 'auto'; }
        renderer.render(scene, camera);
    }

    function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    
    document.getElementById('action-btn').addEventListener('click', handleUiAction);
    document.getElementById('fullscreen-btn').addEventListener('click', () => { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(() => { document.getElementById('fullscreen-btn').style.display = 'none'; }); } else { if (document.exitFullscreen) document.exitFullscreen(); } });
    
    initThree(); 
    // è‡ªåŠ¨å¯åŠ¨ AI
    initThree(); 
</script>
</body>
</html>